use std::{collections::BTreeMap, path::Path};

use anyhow::Result;
#[allow(unused_imports)]
use libafl::Fuzzer; // This may be marked unused, but will make the compiler give you crucial error messages
use libafl::{executors::ExitKind, inputs::Input};
use log::{error, info, warn};
use oas3::spec::Server;

use crate::{
    authentication::build_http_client,
    configuration::Configuration,
    executor::process_response,
    input::OpenApiInput,
    openapi::{
        build_request::build_request_from_input, curl_request::CurlRequest,
        validate_response::Response,
    },
    parameter_feedback::ParameterFeedback,
};

/// Reproduces a given input file generated by the fuzzer (as a crash file or a corpus entry).
pub fn reproduce(input_file: &Path) -> Result<()> {
    let config = Configuration::get().map_err(anyhow::Error::msg)?;
    crate::setup_logging(config);
    let mut api = crate::get_api_spec(
        config
            .openapi_spec
            .as_ref()
            .ok_or_else(|| anyhow!("No OpenAPI specification given"))?,
    )?;
    // Override the `servers` field in the OpenAPI specification if a server override
    // was specified on the CLI.
    if let Some(server_override) = &config.target {
        api.servers = vec![Server {
            url: server_override.as_str().trim_end_matches('/').to_string(),
            description: None,
            variables: BTreeMap::new(),
            extensions: BTreeMap::new(),
        }];
    }
    let inputs = OpenApiInput::from_file(input_file)?;

    let (mut authentication, cookie_store, client) = build_http_client(&api)?;

    println!(
        "Input file {:?} contains {} inputs",
        input_file,
        inputs.0.len()
    );

    let mut parameter_feedback = ParameterFeedback::new(inputs.0.len());

    for (request_index, request) in inputs.0.iter().enumerate() {
        info!("\n-----\nSending request: \n{request}");

        let mut request = request.clone();
        if let Err(error) = request.resolve_parameter_references(&parameter_feedback) {
            error!(
                "Cannot instantiate request: missing value for backreferenced parameter: {error}"
            );
            continue;
        };

        let request_built = match build_request_from_input(
            &client,
            &mut authentication,
            &cookie_store,
            &api,
            &request,
        )
        .map(|builder| builder.build())
        {
            Err(message) => {
                warn!("Could not generate a HTTP request from this input: {message}. Skipping ...");
                continue;
            }
            Ok(Err(message)) => {
                error!("Error building the request: {message}");
                break;
            }
            Ok(Ok(request)) => {
                info!(
                    "Converted to CURL command:\n{}",
                    CurlRequest(&request, &authentication)
                );
                request
            }
        };

        match client.execute(request_built) {
            Ok(response) => {
                let response: Response = response.into();
                let mut exit_kind = ExitKind::Ok;
                process_response(
                    request_index,
                    &request,
                    response.clone(),
                    &api,
                    &config.crash_criteria,
                    &mut exit_kind,
                    &mut parameter_feedback,
                );
                if exit_kind == ExitKind::Crash {
                    if let Ok(text) = response.text() {
                        info!("Response contents printed below: \n{text}")
                    }
                    break;
                } else {
                    info!("Request successful ({})", response.status());
                }
            }
            Err(e) => {
                error!("Error sending the request: {e}");
                break;
            }
        }
    }
    Ok(())
}
