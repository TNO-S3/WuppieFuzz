//! # Wuppiefuzz, a coverage guided REST API fuzzer
//!
//! Wuppiefuzz is a program used for fuzz testing: a method of testing computer programs
//! by sending randomly generated inputs to them. Random inputs are less likely to crash
//! a program than an input generated by a smart human, but fuzz testers compensate by
//! generating many inputs in a short timespan. Fuzz testing has proven very good at
//! detecting certain classes of bugs.
//!
//! This fuzzer is designed to test programs that expose a REST API, and have an API
//! specification describing that API. It then sends HTTP requests to the program that
//! are designed to cause problems, such as deleting non-existent resources or using
//! non-ascii parameter values.
//!
//! This fuzzer is also coverage-guided, which means it measures whether its inputs cover
//! new code in the program under test, and tries to send semi-random inputs that reach
//! new parts of the program under test. For this, it leverages LibAFL, which itself is
//! a library designed for coverage-guided binary fuzzing.

#![warn(missing_docs)]
#![doc(
    html_logo_url = "assets/logo_square.svg",
    html_favicon_url = "assets/favicon.ico"
)]

#[macro_use]
extern crate anyhow;
#[macro_use]
extern crate num_derive;
#[macro_use]
extern crate lazy_static;

#[allow(unused_imports)]
use libafl::Fuzzer; // This may be marked unused, but will make the compiler give you crucial error messages

use anyhow::Result;
use clap::Parser;
use configuration::{Commands, OutputFormat};
use env_logger::{Builder, Env};
use log::warn;
#[cfg(windows)]
use std::ptr::write_volatile;
use std::sync::Arc;

mod authentication;
mod configuration;
pub mod coverage_clients;
mod debug_writer;
mod fuzzer;
pub mod header;
mod initial_corpus;
mod input;
pub mod monitors;
mod openapi;
pub mod openapi_mutator;
mod parameter_feedback;
mod reporting;
mod reproducer;
mod state;
mod wuppie_version;

use crate::{configuration::Configuration, openapi::get_api_spec};

/// The entry point. Dispatches to other modules based on the CLI command.
#[allow(clippy::unit_arg)]
pub fn main() -> Result<()> {
    let cli = configuration::Cli::parse();
    match &cli.command {
        Commands::Version => Ok(wuppie_version::print_version()),
        Commands::License => Ok(wuppie_version::print_license()),
        Commands::Sbom => Ok(wuppie_version::print_sbom()),
        Commands::VerifyAuth { .. } => {
            let config = &Configuration::get().map_err(anyhow::Error::msg)?;
            setup_logging(config);
            let api = get_api_spec(config.openapi_spec.as_ref().unwrap())?;
            authentication::verify_authentication(*api)
        }
        Commands::OutputCorpus {
            corpus_directory,
            openapi_spec,
            report_path,
        } => Ok(initial_corpus::generate_corpus_to_files(
            &*get_api_spec(openapi_spec)?,
            corpus_directory,
            report_path.as_deref(),
        )),
        Commands::Reproduce { crash_file, .. } => reproducer::reproduce(crash_file),
        Commands::Fuzz { .. } => fuzzer::fuzz(),
    }
}

/// Set-up logging according to the given configuration
pub fn setup_logging(clargs: &Configuration) {
    match clargs.output_format {
        OutputFormat::Json => {
            json_env_logger2::builder()
                .filter_level(clargs.log_level)
                .init();
        }
        OutputFormat::HumanReadable => {
            Builder::from_env(Env::default())
                .filter_level(clargs.log_level)
                .init();
        }
    }
}

/// Initializes the authentication module and cookie store and builds a Reqwest HTTP client
fn build_http_client() -> Result<
    (
        authentication::Authentication,
        Arc<reqwest_cookie_store::CookieStoreMutex>,
        reqwest::blocking::Client,
    ),
    anyhow::Error,
> {
    // Load auth information from the configuration
    let mut authentication = authentication::initialize()?;
    // Make a cookie jar for our client
    let cookie_store = std::sync::Arc::new(reqwest_cookie_store::CookieStoreMutex::new(
        reqwest_cookie_store::CookieStore::default(),
    ));
    // Construct a client with the authentication and static headers
    let client_builder =
        reqwest::blocking::Client::builder().cookie_provider(std::sync::Arc::clone(&cookie_store));
    let mut default_headers = authentication.generate_headers();
    default_headers.extend(header::get_default_headers()?);
    let client = client_builder.default_headers(default_headers).build()?;

    Ok((authentication, cookie_store, client))
}
