//! # Wuppiefuzz, a coverage guided REST API fuzzer
//!
//! Wuppiefuzz is a program used for fuzz testing: a method of testing computer programs
//! by sending randomly generated inputs to them. Random inputs are less likely to crash
//! a program than an input generated by a smart human, but fuzz testers compensate by
//! generating many inputs in a short timespan. Fuzz testing has proven very good at
//! detecting certain classes of bugs.
//!
//! This fuzzer is designed to test programs that expose a REST API, and have an API
//! specification describing that API. It then sends HTTP requests to the program that
//! are designed to cause problems, such as deleting non-existent resources or using
//! non-ascii parameter values.
//!
//! This fuzzer is also coverage-guided, which means it measures whether its inputs cover
//! new code in the program under test, and tries to send semi-random inputs that reach
//! new parts of the program under test. For this, it leverages LibAFL, which itself is
//! a library designed for coverage-guided binary fuzzing.

#![warn(missing_docs)]
#![doc(
    html_logo_url = "assets/logo_square.svg",
    html_favicon_url = "assets/favicon.ico"
)]

#[macro_use]
extern crate anyhow;
#[macro_use]
extern crate num_derive;
#[macro_use]
extern crate lazy_static;

#[cfg(windows)]
use std::ptr::write_volatile;

use anyhow::Result;
use clap::Parser;
use configuration::{Commands, OutputFormat};
use env_logger::{Builder, Env};
use indexmap::IndexMap;
#[allow(unused_imports)]
use libafl::Fuzzer; // This may be marked unused, but will make the compiler give you crucial error messages
use log::warn;
use openapiv3::Server;

mod authentication;
mod configuration;
pub mod coverage_clients;
pub mod executor;
mod fuzzer;
pub mod header;
mod initial_corpus;
mod input;
pub mod monitors;
mod openapi;
pub mod openapi_mutator;
mod parameter_access;
mod parameter_feedback;
mod reporting;
mod reproducer;
mod state;
mod wuppie_version;

use crate::{configuration::Configuration, openapi::get_api_spec};

/// The entry point. Dispatches to other modules based on the CLI command.
#[allow(clippy::unit_arg)]
pub fn main() -> Result<()> {
    let cli = configuration::Cli::parse();
    match &cli.command {
        Commands::Version => Ok(wuppie_version::print_version()),
        Commands::License => Ok(wuppie_version::print_license()),
        Commands::Sbom => Ok(wuppie_version::print_sbom()),
        Commands::VerifyAuth { .. } => {
            let config = &Configuration::get().map_err(anyhow::Error::msg)?;
            setup_logging(config);
            let mut api = get_api_spec(config.openapi_spec.as_ref().unwrap())?;
            // Override the `servers` field in the OpenAPI specification if a server override
            // was specified on the CLI.
            if let Some(server_override) = &config.target {
                api.servers = vec![Server {
                    url: server_override.as_str().trim_end_matches('/').to_string(),
                    description: None,
                    variables: None,
                    extensions: IndexMap::new(),
                }];
            }
            authentication::verify_authentication(*api)
        }
        Commands::OutputCorpus {
            corpus_directory,
            openapi_spec,
            report_path,
            log_level: _,
        } => {
            let config = &Configuration::get().map_err(anyhow::Error::msg)?;
            setup_logging(config);
            Ok(initial_corpus::generate_corpus_to_files(
                &*get_api_spec(openapi_spec)?,
                corpus_directory,
                report_path.as_deref(),
            ))
        }
        Commands::Reproduce { crash_file, .. } => reproducer::reproduce(crash_file),
        Commands::Fuzz { .. } => fuzzer::fuzz(),
    }
}

/// Set-up logging according to the given configuration
pub fn setup_logging(clargs: &Configuration) {
    match clargs.output_format {
        OutputFormat::Json => {
            json_env_logger2::builder()
                .filter_level(clargs.log_level)
                .init();
        }
        OutputFormat::HumanReadable => {
            Builder::from_env(Env::default())
                .filter_level(clargs.log_level)
                .init();
        }
    }
}
